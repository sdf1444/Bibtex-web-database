{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\nvar AbstractNextPossibleTokensWalker = /** @class */function (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this) || this;\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    // immutable for the win\n    this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n    // stop scanning once we found the path\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n  return AbstractNextPossibleTokensWalker;\n}(RestWalker);\nexport { AbstractNextPossibleTokensWalker };\nvar NextAfterTokenWalker = /** @class */function (_super) {\n  __extends(NextAfterTokenWalker, _super);\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path) || this;\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new Flat({\n        definition: fullRest\n      });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  };\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */function (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this) || this;\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n  return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker);\nexport { AbstractNextTerminalAfterProductionWalker };\nvar NextTerminalAfterManyWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterManyWalker };\nvar NextTerminalAfterManySepWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterManySepWalker };\nvar NextTerminalAfterAtLeastOneWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterAtLeastOneWalker };\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  }\n  // avoid side effects\n  currPath = cloneArr(currPath);\n  var result = [];\n  var i = 0;\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n    if (prod instanceof Flat) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      var newDef = [new Flat({\n        definition: prod.definition\n      }), new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, function (currAlt) {\n        result = getAlternativesForProd(currAlt.definition);\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  });\n  return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!isEmpty(possiblePaths)) {\n    var currPath = possiblePaths.pop();\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack;\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue;\n    }\n    var prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      var newRuleStack = cloneArr(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = cloneArr(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      var nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Flat) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = cloneArr(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = cloneArr(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","RestWalker","cloneArr","drop","dropRight","first","_first","forEach","isEmpty","last","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","AbstractNextPossibleTokensWalker","_super","topProd","path","_this","call","possibleTokTypes","nextProductionName","nextProductionOccurrence","found","isAtEndOfPath","startWalking","ruleStack","name","Error","reverse","occurrenceStack","pop","updateExpectedNext","walk","prod","prevRest","walkProdRef","refProd","currRest","referencedRule","idx","fullRest","concat","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","walkTerminal","terminal","terminalType","restProd","definition","AbstractNextTerminalAfterProductionWalker","topRule","occurrence","result","token","undefined","isEndOfRule","NextTerminalAfterManyWalker","apply","arguments","walkMany","manyProd","firstAfterMany","NextTerminalAfterManySepWalker","walkManySep","manySepProd","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","walkAtLeastOne","atLeastOneProd","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","walkAtLeastOneSep","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","currPath","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","length","newDef","separator","currAlt","push","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","nonTerminalName","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(RestWalker));\nexport { AbstractNextPossibleTokensWalker };\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new Flat({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker));\nexport { AbstractNextTerminalAfterProductionWalker };\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterManyWalker };\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterManySepWalker };\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterAtLeastOneWalker };\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule =\n                firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token =\n                    firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = cloneArr(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Flat) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            var newDef = [\n                new Flat({ definition: prod.definition }),\n                new Repetition({\n                    definition: [\n                        new Terminal({ terminalType: prod.separator })\n                    ].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [\n                        new Terminal({ terminalType: prod.separator })\n                    ].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, function (currAlt) {\n                result = getAlternativesForProd(currAlt.definition);\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i)\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!isEmpty(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            var newRuleStack = cloneArr(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = cloneArr(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new Terminal({\n                terminalType: prod.separator\n            });\n            var secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new Terminal({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Flat) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = cloneArr(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = cloneArr(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}