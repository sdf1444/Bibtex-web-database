{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType } from \"./lexer_public\";\nimport { compact, contains, defaults, difference, filter, find, first, flatten, forEach, has, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, mapValues, packArray, PRINT_ERROR, reduce, reject } from \"../utils/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices } from \"./reg_exp\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nvar PATTERN = \"PATTERN\";\nexport var DEFAULT_MODE = \"defaultMode\";\nexport var MODES = \"modes\";\nexport var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n  SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n  SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: function tracer(msg, action) {\n      return action();\n    }\n  });\n  var tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n    initCharCodeToOptimizedIndexMap();\n  });\n  var onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", function () {\n    onlyRelevantTypes = reject(tokenTypes, function (currType) {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  var hasCustom = false;\n  var allTransformedPatterns;\n  tracer(\"Transform Patterns\", function () {\n    hasCustom = false;\n    allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n      var currPattern = currType[PATTERN];\n      /* istanbul ignore else */\n      if (isRegExp(currPattern)) {\n        var regExpSource = currPattern.source;\n        if (regExpSource.length === 1 &&\n        // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\") {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" &&\n        // not a meta character\n        !contains([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction(currPattern)) {\n        hasCustom = true;\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return {\n          exec: currPattern\n        };\n      } else if (has(currPattern, \"exec\")) {\n        hasCustom = true;\n        // ICustomPattern\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          var wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  var patternIdxToType;\n  var patternIdxToGroup;\n  var patternIdxToLongerAltIdx;\n  var patternIdxToPushMode;\n  var patternIdxToPopMode;\n  tracer(\"misc mapping\", function () {\n    patternIdxToType = map(onlyRelevantTypes, function (currType) {\n      return currType.tokenTypeIdx;\n    });\n    patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n      var groupName = clazz.GROUP;\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdx = map(onlyRelevantTypes, function (clazz) {\n      var longerAltType = clazz.LONGER_ALT;\n      if (longerAltType) {\n        var longerAltIdx = indexOf(onlyRelevantTypes, longerAltType);\n        return longerAltIdx;\n      }\n    });\n    patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) {\n      return clazz.PUSH_MODE;\n    });\n    patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n      return has(clazz, \"POP_MODE\");\n    });\n  });\n  var patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", function () {\n    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n      return false;\n    });\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return tokType.LINE_BREAKS;\n        } else {\n          if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n            return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          }\n        }\n      });\n    }\n  });\n  var patternIdxToIsCustom;\n  var patternIdxToShort;\n  var emptyGroups;\n  var patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", function () {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n      var groupName = clazz.GROUP;\n      if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n      return acc;\n    }, {});\n    patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdx[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  var canBeOptimized = true;\n  var charCodeToPatternIdxToConfig = [];\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", function () {\n      charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n        if (typeof currTokType.PATTERN === \"string\") {\n          var charCode = currTokType.PATTERN.charCodeAt(0);\n          var optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray(currTokType.START_CHARS_HINT)) {\n          var lastOptimizedIdx_1;\n          forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n            var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n            // Avoid adding the config multiple times\n            if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n              lastOptimizedIdx_1 = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") + \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n            }\n          } else {\n            var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            /* istanbul ignore if */\n            // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n            // the first should be a different validation and the second cannot be tested.\n            if (isEmpty(optimizedCodes)) {\n              // we cannot understand what codes may start possible matches\n              // The optimization correctness requires knowing start codes for ALL patterns.\n              // Not actually sure this is an error, no debug message\n              canBeOptimized = false;\n            }\n            forEach(optimizedCodes, function (code) {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n          }\n          canBeOptimized = false;\n        }\n        return result;\n      }, []);\n    });\n  }\n  tracer(\"ArrayPacking\", function () {\n    charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig);\n  });\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n  var errors = [];\n  var missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  var invalidResult = findInvalidPatterns(missingResult.valid);\n  var validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n  var errors = [];\n  var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n    return isRegExp(currTokType[PATTERN]);\n  });\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n  var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n    return !has(currType, PATTERN);\n  });\n  var errors = map(tokenTypesWithMissingPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nexport function findInvalidPatterns(tokenTypes) {\n  var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return !isRegExp(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n  });\n  var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a\" + \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n  var EndAnchorFinder = /** @class */function (_super) {\n    __extends(EndAnchorFinder, _super);\n    function EndAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.found = false;\n      return _this;\n    }\n    EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n      this.found = true;\n    };\n    return EndAnchorFinder;\n  }(BaseRegExpVisitor);\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" + \"\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n  var matchesEmptyString = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern.test(\"\");\n  });\n  var errors = map(matchesEmptyString, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n  var StartAnchorFinder = /** @class */function (_super) {\n    __extends(StartAnchorFinder, _super);\n    function StartAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.found = false;\n      return _this;\n    }\n    StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n      this.found = true;\n    };\n    return StartAnchorFinder;\n  }(BaseRegExpVisitor);\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" + \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n  var invalidFlags = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  var errors = map(invalidFlags, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n  var found = [];\n  var identicalPatterns = map(tokenTypes, function (outerType) {\n    return reduce(tokenTypes, function (result, innerType) {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !contains(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n        // in essence we are creating Equivalence classes on equality relation.\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact(identicalPatterns);\n  var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n    return currIdenticalSet.length > 1;\n  });\n  var errors = map(duplicatePatterns, function (setOfIdentical) {\n    var tokenTypeNames = map(setOfIdentical, function (currType) {\n      return currType.name;\n    });\n    var dupPatternSrc = first(setOfIdentical).PATTERN;\n    return {\n      message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" + (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n  var invalidTypes = filter(tokenTypes, function (clazz) {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n    var group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n  var errors = map(invalidTypes, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n  var invalidModes = filter(tokenTypes, function (clazz) {\n    return clazz.PUSH_MODE !== undefined && !contains(validModes, clazz.PUSH_MODE);\n  });\n  var errors = map(invalidModes, function (tokType) {\n    var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" + \"which does not exist\";\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n  var errors = [];\n  var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n    var pattern = tokType.PATTERN;\n    if (pattern === Lexer.NA) {\n      return result;\n    }\n    // a more comprehensive validation for all forms of regExps would require\n    // deeper regExp analysis capabilities\n    if (isString(pattern)) {\n      result.push({\n        str: pattern,\n        idx: idx,\n        tokenType: tokType\n      });\n    } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n      result.push({\n        str: pattern.source,\n        idx: idx,\n        tokenType: tokType\n      });\n    }\n    return result;\n  }, []);\n  forEach(tokenTypes, function (tokType, testIdx) {\n    forEach(canBeTested, function (_a) {\n      var str = _a.str,\n        idx = _a.idx,\n        tokenType = _a.tokenType;\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" + (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") + \"in the lexer's definition.\\n\" + \"See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction testTokenType(str, pattern) {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    var regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction noMetaChar(regExp) {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n  return find(metaChars, function (char) {\n    return regExp.source.indexOf(char) !== -1;\n  }) === undefined;\n}\nexport function addStartOfInput(pattern) {\n  var flags = pattern.ignoreCase ? \"i\" : \"\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nexport function addStickyFlag(pattern) {\n  var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(\"\" + pattern.source, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var errors = [];\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n  if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" + \"which does not exist\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n      forEach(currModeValue, function (currTokType, currIdx) {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" + (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        }\n      });\n    });\n  }\n  return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var warnings = [];\n  var hasAnyLineBreak = false;\n  var allTokenTypes = compact(flatten(mapValues(lexerDefinition.modes, function (tokTypes) {\n    return tokTypes;\n  })));\n  var concreteTokenTypes = reject(allTokenTypes, function (currType) {\n    return currType[PATTERN] === Lexer.NA;\n  });\n  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach(concreteTokenTypes, function (tokType) {\n      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        var message = buildLineBreakIssueMessage(tokType, currIssue);\n        var warningDescriptor = {\n          message: message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\" + \"\\tThis Lexer has been defined to track line and column information,\\n\" + \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" + \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n  return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n  var clonedResult = {};\n  var groupKeys = keys(emptyGroups);\n  forEach(groupKeys, function (currKey) {\n    var currGroupValue = emptyGroups[currKey];\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n  var pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function isShortPattern(pattern) {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport var LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function test(text) {\n    var len = text.length;\n    for (var i = this.lastIndex; i < len; i++) {\n      var c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return {\n        issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return \"Warning: unable to identify line terminator usage in pattern.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + (\"\\t Root cause: \" + details.errMsg + \".\\n\") + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction getCharCodes(charsOrCodes) {\n  var charCodes = map(charsOrCodes, function (numOrString) {\n    if (isString(numOrString) && numOrString.length > 0) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\nexport var minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nexport function charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (var i = 0; i < 65536; i++) {\n      /* tslint:disable */\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n      /* tslint:enable */\n    }\n  }\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","BaseRegExpVisitor","Lexer","LexerDefinitionErrorType","compact","contains","defaults","difference","filter","find","first","flatten","forEach","has","indexOf","isArray","isEmpty","isFunction","isRegExp","isString","isUndefined","keys","map","mapValues","packArray","PRINT_ERROR","reduce","reject","canMatchCharCode","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","getRegExpAst","PATTERN","DEFAULT_MODE","MODES","SUPPORT_STICKY","RegExp","sticky","disableSticky","enableSticky","analyzeTokenTypes","tokenTypes","options","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","msg","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","source","length","addStickyFlag","addStartOfInput","exec","escapedRegExpString","replace","wrappedRegExp","Error","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdx","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","undefined","longerAltType","LONGER_ALT","longerAltIdx","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","tokType","LINE_BREAKS","checkLineBreaksIssues","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","idx","pattern","longerAlt","canLineTerminator","isCustom","short","group","push","pop","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","result","currTokType","charCode","charCodeAt","optimizedIdx","charCodeToOptimizedIndex","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx_1","charOrInt","currOptimizedIdx","unicode","ensureOptimizations","toString","optimizedCodes","code","name","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","concat","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","message","type","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","EndAnchorFinder","_super","_this","apply","arguments","found","visitEndAnchor","node","invalidRegex","regexpAst","endAnchorVisitor","visit","e","test","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_a","testTokenType","UNREACHABLE_PATTERN","regExpArray","index","regExp","metaChars","char","flags","ignoreCase","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","tokTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","i","lastIndex","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","charCodes","numOrString","key","value","minOptimizationVal","charCodeToOptimizedIdxMap"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/scan/lexer.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType } from \"./lexer_public\";\nimport { compact, contains, defaults, difference, filter, find, first, flatten, forEach, has, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, mapValues, packArray, PRINT_ERROR, reduce, reject } from \"../utils/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices } from \"./reg_exp\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nvar PATTERN = \"PATTERN\";\nexport var DEFAULT_MODE = \"defaultMode\";\nexport var MODES = \"modes\";\nexport var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n    SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n    SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function (msg, action) { return action(); }\n    });\n    var tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n    });\n    var onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = reject(tokenTypes, function (currType) {\n            return currType[PATTERN] === Lexer.NA;\n        });\n    });\n    var hasCustom = false;\n    var allTransformedPatterns;\n    tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n            var currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (isRegExp(currPattern)) {\n                var regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\") {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !contains([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\"\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if (isFunction(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (has(currPattern, \"exec\")) {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    var wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    var patternIdxToType;\n    var patternIdxToGroup;\n    var patternIdxToLongerAltIdx;\n    var patternIdxToPushMode;\n    var patternIdxToPopMode;\n    tracer(\"misc mapping\", function () {\n        patternIdxToType = map(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });\n        patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n            var groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if (isString(groupName)) {\n                return groupName;\n            }\n            else if (isUndefined(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdx = map(onlyRelevantTypes, function (clazz) {\n            var longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                var longerAltIdx = indexOf(onlyRelevantTypes, longerAltType);\n                return longerAltIdx;\n            }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });\n        patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n            return has(clazz, \"POP_MODE\");\n        });\n    });\n    var patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) { return false; });\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    return tokType.LINE_BREAKS;\n                }\n                else {\n                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n                        return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n                    }\n                }\n            });\n        }\n    });\n    var patternIdxToIsCustom;\n    var patternIdxToShort;\n    var emptyGroups;\n    var patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n            var groupName = clazz.GROUP;\n            if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdx[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx]\n            };\n        });\n    });\n    var canBeOptimized = true;\n    var charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n            charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    var charCode = currTokType.PATTERN.charCodeAt(0);\n                    var optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if (isArray(currTokType.START_CHARS_HINT)) {\n                    var lastOptimizedIdx_1;\n                    forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n                        var charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n                            lastOptimizedIdx_1 = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (isRegExp(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            PRINT_ERROR(\"\" + failedOptimizationPrefixMsg +\n                                (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if (isEmpty(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        forEach(optimizedCodes, function (code) {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        PRINT_ERROR(\"\" + failedOptimizationPrefixMsg +\n                            (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    tracer(\"ArrayPacking\", function () {\n        charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig);\n    });\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n    };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n    var errors = [];\n    var missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    var invalidResult = findInvalidPatterns(missingResult.valid);\n    var validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    var errors = [];\n    var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n        return isRegExp(currTokType[PATTERN]);\n    });\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n    var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n        return !has(currType, PATTERN);\n    });\n    var errors = map(tokenTypesWithMissingPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors: errors, valid: valid };\n}\nexport function findInvalidPatterns(tokenTypes) {\n    var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (!isRegExp(pattern) &&\n            !isFunction(pattern) &&\n            !has(pattern, \"exec\") &&\n            !isString(pattern));\n    });\n    var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors: errors, valid: valid };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n    var EndAnchorFinder = /** @class */ (function (_super) {\n        __extends(EndAnchorFinder, _super);\n        function EndAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n            this.found = true;\n        };\n        return EndAnchorFinder;\n    }(BaseRegExpVisitor));\n    var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = getRegExpAst(pattern);\n            var endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    var errors = map(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n    var matchesEmptyString = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern.test(\"\");\n    });\n    var errors = map(matchesEmptyString, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n    var StartAnchorFinder = /** @class */ (function (_super) {\n        __extends(StartAnchorFinder, _super);\n        function StartAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n            this.found = true;\n        };\n        return StartAnchorFinder;\n    }(BaseRegExpVisitor));\n    var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = getRegExpAst(pattern);\n            var startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    var errors = map(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n    var invalidFlags = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (pattern instanceof RegExp && (pattern.multiline || pattern.global));\n    });\n    var errors = map(invalidFlags, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n    var found = [];\n    var identicalPatterns = map(tokenTypes, function (outerType) {\n        return reduce(tokenTypes, function (result, innerType) {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !contains(found, innerType) &&\n                innerType.PATTERN !== Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = compact(identicalPatterns);\n    var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n    });\n    var errors = map(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = map(setOfIdentical, function (currType) {\n            return currType.name;\n        });\n        var dupPatternSrc = first(setOfIdentical).PATTERN;\n        return {\n            message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" +\n                (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical\n        };\n    });\n    return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n    var invalidTypes = filter(tokenTypes, function (clazz) {\n        if (!has(clazz, \"GROUP\")) {\n            return false;\n        }\n        var group = clazz.GROUP;\n        return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n    });\n    var errors = map(invalidTypes, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n    var invalidModes = filter(tokenTypes, function (clazz) {\n        return (clazz.PUSH_MODE !== undefined &&\n            !contains(validModes, clazz.PUSH_MODE));\n    });\n    var errors = map(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" +\n            \"which does not exist\";\n        return {\n            message: msg,\n            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType]\n        };\n    });\n    return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n    var errors = [];\n    var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n            result.push({ str: pattern, idx: idx, tokenType: tokType });\n        }\n        else if (isRegExp(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx: idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    forEach(tokenTypes, function (tokType, testIdx) {\n        forEach(canBeTested, function (_a) {\n            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" +\n                    (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") +\n                    \"in the lexer's definition.\\n\" +\n                    \"See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n                errors.push({\n                    message: msg,\n                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType]\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if (isFunction(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if (has(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    var metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\"\n    ];\n    return (find(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) ===\n        undefined);\n}\nexport function addStartOfInput(pattern) {\n    var flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nexport function addStickyFlag(pattern) {\n    var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"\" + pattern.source, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var errors = [];\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n    }\n    if (!has(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n    }\n    if (has(lexerDefinition, MODES) &&\n        has(lexerDefinition, DEFAULT_MODE) &&\n        !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" +\n                \"which does not exist\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n    }\n    if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n            forEach(currModeValue, function (currTokType, currIdx) {\n                if (isUndefined(currTokType)) {\n                    errors.push({\n                        message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" +\n                            (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var warnings = [];\n    var hasAnyLineBreak = false;\n    var allTokenTypes = compact(flatten(mapValues(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));\n    var concreteTokenTypes = reject(allTokenTypes, function (currType) { return currType[PATTERN] === Lexer.NA; });\n    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        forEach(concreteTokenTypes, function (tokType) {\n            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                var message = buildLineBreakIssueMessage(tokType, currIssue);\n                var warningDescriptor = {\n                    message: message,\n                    type: currIssue.issue,\n                    tokenType: tokType\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n        });\n    }\n    return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n    var clonedResult = {};\n    var groupKeys = keys(emptyGroups);\n    forEach(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if (isArray(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n    var pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        return false;\n    }\n    else if (isFunction(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if (has(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if (isString(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport var LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        var len = text.length;\n        for (var i = this.lastIndex; i < len; i++) {\n            var c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (isRegExp(tokType.PATTERN)) {\n            try {\n                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message\n                };\n            }\n            return false;\n        }\n        else if (isString(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            (\"\\t Root cause: \" + details.errMsg + \".\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    var charCodes = map(charsOrCodes, function (numOrString) {\n        if (isString(numOrString) && numOrString.length > 0) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nexport var minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nexport function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var i = 0; i < 65536; i++) {\n            /* tslint:disable */\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n            /* tslint:enable */\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}