{"ast":null,"code":"import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { getKeyForAltIndex } from \"../../grammar/keys\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */function () {\n  function TreeBuilder() {}\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.LAST_EXPLICIT_RULE_STACK = [];\n    this.CST_STACK = [];\n    this.outputCst = has(config, \"outputCst\") ? config.outputCst : DEFAULT_PARSER_CONFIG.outputCst;\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP;\n      this.cstFinallyStateUpdate = NOOP;\n      this.cstPostTerminal = NOOP;\n      this.cstPostNonTerminal = NOOP;\n      this.cstPostRule = NOOP;\n      this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;\n      this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;\n      this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;\n      this.manyInternal = this.manyInternalNoCst;\n      this.orInternal = this.orInternalNoCst;\n      this.optionInternal = this.optionInternalNoCst;\n      this.atLeastOneInternal = this.atLeastOneInternalNoCst;\n      this.manySepFirstInternal = this.manySepFirstInternalNoCst;\n      this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP;\n        this.setNodeLocationFromNode = NOOP;\n        this.cstPostRule = NOOP;\n        this.setInitialNodeLocation = NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n   *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n    * @param cstNode\n   */\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  // CST\n  TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {\n    var cstNode = {\n      name: nestedName,\n      fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] + nestedName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.LAST_EXPLICIT_RULE_STACK.pop();\n    this.CST_STACK.pop();\n  };\n  TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {\n    var lastCstNode = this.CST_STACK.pop();\n    // TODO: the naming is bad, this should go directly to the\n    //       (correct) cstLocation update method\n    //       e.g if we put other logic in postRule...\n    this.cstPostRule(lastCstNode);\n  };\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode or its nested children.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode or its nested children.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    // Avoid side effects due to back tracking\n    // TODO: This costs a 2-3% in performance, A flag on IParserConfig\n    //   could be used to get rid of this conditional, but not sure its worth the effort\n    //   and API complexity.\n    if (this.isBackTracking() !== true) {\n      var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n  TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {\n    var nestedName;\n    if (methodOpts.NAME !== undefined) {\n      nestedName = methodOpts.NAME;\n      this.nestedRuleInvocationStateUpdate(nestedName, laKey);\n      return nestedName;\n    } else {\n      return undefined;\n    }\n  };\n  TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {\n    var ruleIdx = this.getLastExplicitRuleShortName();\n    var shortName = getKeyForAltIndex(ruleIdx, methodKeyIdx, occurrence, altIdx);\n    var nestedName;\n    if (methodOpts.NAME !== undefined) {\n      nestedName = methodOpts.NAME;\n      this.nestedRuleInvocationStateUpdate(nestedName, shortName);\n      return {\n        shortName: shortName,\n        nestedName: nestedName\n      };\n    } else {\n      return undefined;\n    }\n  };\n  TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {\n    var cstStack = this.CST_STACK;\n    var nestedRuleCst = cstStack[cstStack.length - 1];\n    this.nestedRuleFinallyStateUpdate();\n    // this return a different result than the previous invocation because \"nestedRuleFinallyStateUpdate\" pops the cst stack\n    var parentCstNode = cstStack[cstStack.length - 1];\n    addNoneTerminalToCst(parentCstNode, nestedName, nestedRuleCst);\n    this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n    return this.RULE_STACK[lastExplictIndex];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];\n    return this.RULE_STACK[lastExplicitIndex];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n    return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n  TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {\n    this.RULE_OCCURRENCE_STACK.push(1);\n    this.RULE_STACK.push(shortNameKey);\n    this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);\n  };\n  TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    // NOOP when cst is disabled\n    this.cstNestedFinallyStateUpdate();\n  };\n  return TreeBuilder;\n}();\nexport { TreeBuilder };","map":{"version":3,"names":["addNoneTerminalToCst","addTerminalToCst","setNodeLocationFull","setNodeLocationOnlyOffset","has","isUndefined","NOOP","createBaseSemanticVisitorConstructor","createBaseVisitorConstructorWithDefaults","getKeyForAltIndex","DEFAULT_PARSER_CONFIG","TreeBuilder","prototype","initTreeBuilder","config","LAST_EXPLICIT_RULE_STACK","CST_STACK","outputCst","nodeLocationTracking","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","getLastExplicitRuleShortName","getLastExplicitRuleShortNameNoCst","getPreviousExplicitRuleShortName","getPreviousExplicitRuleShortNameNoCst","getLastExplicitRuleOccurrenceIndex","getLastExplicitRuleOccurrenceIndexNoCst","manyInternal","manyInternalNoCst","orInternal","orInternalNoCst","optionInternal","optionInternalNoCst","atLeastOneInternal","atLeastOneInternalNoCst","manySepFirstInternal","manySepFirstInternalNoCst","atLeastOneSepFirstInternal","atLeastOneSepFirstInternalNoCst","test","recoveryEnabled","setNodeLocationFromToken","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","Error","cstNode","location","startOffset","NaN","endOffset","LA","startLine","startColumn","endLine","endColumn","nextToken","cstNestedInvocationStateUpdate","nestedName","shortName","name","fullName","shortRuleNameToFull","children","push","fullRuleName","RULE_STACK","length","pop","cstNestedFinallyStateUpdate","lastCstNode","ruleCstNode","prevToken","loc","key","consumedToken","rootCst","ruleCstResult","ruleName","isBackTracking","preCstNode","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","className","allRuleNames","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","nestedRuleBeforeClause","methodOpts","laKey","NAME","undefined","nestedRuleInvocationStateUpdate","nestedAltBeforeClause","occurrence","methodKeyIdx","altIdx","ruleIdx","nestedRuleFinallyClause","cstStack","nestedRuleCst","nestedRuleFinallyStateUpdate","parentCstNode","lastExplictIndex","ruleStack","lastExplicitIndex","RULE_OCCURRENCE_STACK","occurrenceStack","nestedRuleName","shortNameKey"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js"],"sourcesContent":["import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { getKeyForAltIndex } from \"../../grammar/keys\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.LAST_EXPLICIT_RULE_STACK = [];\n        this.CST_STACK = [];\n        this.outputCst = has(config, \"outputCst\")\n            ? config.outputCst\n            : DEFAULT_PARSER_CONFIG.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = NOOP;\n            this.cstFinallyStateUpdate = NOOP;\n            this.cstPostTerminal = NOOP;\n            this.cstPostNonTerminal = NOOP;\n            this.cstPostRule = NOOP;\n            this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;\n            this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;\n            this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;\n            this.manyInternal = this.manyInternalNoCst;\n            this.orInternal = this.orInternalNoCst;\n            this.optionInternal = this.optionInternalNoCst;\n            this.atLeastOneInternal = this.atLeastOneInternalNoCst;\n            this.manySepFirstInternal = this.manySepFirstInternalNoCst;\n            this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = NOOP;\n                    this.setNodeLocationFromNode = NOOP;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = (setNodeLocationOnlyOffset);\n                    this.setNodeLocationFromNode = (setNodeLocationOnlyOffset);\n                    this.cstPostRule = NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = NOOP;\n                    this.setNodeLocationFromNode = NOOP;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = NOOP;\n                this.setNodeLocationFromNode = NOOP;\n                this.cstPostRule = NOOP;\n                this.setInitialNodeLocation = NOOP;\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    // CST\n    TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {\n        var cstNode = {\n            name: nestedName,\n            fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] +\n                nestedName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);\n        var cstNode = {\n            name: fullRuleName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.LAST_EXPLICIT_RULE_STACK.pop();\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {\n        var lastCstNode = this.CST_STACK.pop();\n        // TODO: the naming is bad, this should go directly to the\n        //       (correct) cstLocation update method\n        //       e.g if we put other logic in postRule...\n        this.cstPostRule(lastCstNode);\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode or its nested children.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode or its nested children.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        // Avoid side effects due to back tracking\n        // TODO: This costs a 2-3% in performance, A flag on IParserConfig\n        //   could be used to get rid of this conditional, but not sure its worth the effort\n        //   and API complexity.\n        if (this.isBackTracking() !== true) {\n            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n            addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n            // This is only used when **both** error recovery and CST Output are enabled.\n            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n        }\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {\n        var nestedName;\n        if (methodOpts.NAME !== undefined) {\n            nestedName = methodOpts.NAME;\n            this.nestedRuleInvocationStateUpdate(nestedName, laKey);\n            return nestedName;\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {\n        var ruleIdx = this.getLastExplicitRuleShortName();\n        var shortName = getKeyForAltIndex(ruleIdx, methodKeyIdx, occurrence, altIdx);\n        var nestedName;\n        if (methodOpts.NAME !== undefined) {\n            nestedName = methodOpts.NAME;\n            this.nestedRuleInvocationStateUpdate(nestedName, shortName);\n            return {\n                shortName: shortName,\n                nestedName: nestedName\n            };\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {\n        var cstStack = this.CST_STACK;\n        var nestedRuleCst = cstStack[cstStack.length - 1];\n        this.nestedRuleFinallyStateUpdate();\n        // this return a different result than the previous invocation because \"nestedRuleFinallyStateUpdate\" pops the cst stack\n        var parentCstNode = cstStack[cstStack.length - 1];\n        addNoneTerminalToCst(parentCstNode, nestedName, nestedRuleCst);\n        this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n        return this.RULE_STACK[lastExplictIndex];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];\n        return this.RULE_STACK[lastExplicitIndex];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n        return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {\n        this.RULE_OCCURRENCE_STACK.push(1);\n        this.RULE_STACK.push(shortNameKey);\n        this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);\n    };\n    TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstNestedFinallyStateUpdate();\n    };\n    return TreeBuilder;\n}());\nexport { TreeBuilder };\n//# sourceMappingURL=tree_builder.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}