{"ast":null,"code":"import { cloneArr, cloneObj, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values } from \"../../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../../grammar/keys\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException } from \"../../exceptions_public\";\nimport { PROD_TYPE } from \"../../grammar/lookahead\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker } from \"../../grammar/interpreter\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\";\nimport { EOF } from \"../../../scan/tokens_public\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../../scan/tokens\";\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */function () {\n  function RecognizerEngine() {}\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = classNameFromInstance(this);\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.allRuleNames = [];\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (has(tokenVocabulary, \"modes\") && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n      var allTokenTypes = flatten(values(tokenVocabulary.modes));\n      var uniqueTokens = uniq(allTokenTypes);\n      this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = cloneObj(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    }\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    /* tslint:disable */\n    this.tokensMap[\"EOF\"] = EOF;\n    // TODO: This check may not be accurate for multi mode lexers\n    var noTokenCategoriesUsed = every(values(tokenVocabulary), function (tokenConstructor) {\n      return isEmpty(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap));\n  };\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n    var resyncEnabled = has(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    /* tslint:disable */\n    var shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n    /* tslint:enable */\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    function invokeRuleWithTry(args) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } else {\n          return impl.apply(this, args);\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n      } finally {\n        this.ruleFinallyStateUpdate();\n      }\n    }\n    var wrappedGrammarRule;\n    wrappedGrammarRule = function wrappedGrammarRule(idxInCallingRule, args) {\n      if (idxInCallingRule === void 0) {\n        idxInCallingRule = 0;\n      }\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n      return invokeRuleWithTry.call(this, args);\n    };\n    var ruleNamePropName = \"ruleName\";\n    wrappedGrammarRule[ruleNamePropName] = ruleName;\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n    return wrappedGrammarRule;\n  };\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1;\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n    if (isRecognitionException(e)) {\n      var recogError = e;\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          // to be handled Further up the call stack\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState();\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  };\n  // Implementation of parsing DSL\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);\n    try {\n      return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(key, nestedName);\n      }\n    }\n  };\n  RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return undefined;\n  };\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n    try {\n      return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n  RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n    var key = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);\n  };\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    }\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(options, laKey);\n    try {\n      this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this);\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n    try {\n      return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n  RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n        lookaheadFunction = function lookaheadFunction() {\n          return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    var notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker,\n    // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(options, laKey);\n    try {\n      this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n  RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key);\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this);\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n    }\n  };\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    }\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition();\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration;\n  };\n  RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {\n    var alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);\n    try {\n      var alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n      var laFunc = this.getLaFuncFromCache(laKey);\n      var altIdxToTake = laFunc.call(this, alts);\n      if (altIdxToTake !== undefined) {\n        var chosenAlternative = alts[altIdxToTake];\n        var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, OR_IDX, altIdxToTake);\n        try {\n          return chosenAlternative.ALT.call(this);\n        } finally {\n          if (nestedAltBeforeClauseResult !== undefined) {\n            this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);\n          }\n        }\n      }\n      this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate();\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      ruleResult = ruleToCall.call(this, idx, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n    throw e;\n  };\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n    try {\n      var nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n    throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n  };\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled &&\n    // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = cloneArr(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK,\n      LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK\n    };\n  };\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName, shortName);\n  };\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), EOF);\n  };\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    this.LAST_EXPLICIT_RULE_STACK = [];\n    // TODO: extract a specific rest for TreeBuilder trait\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n  return RecognizerEngine;\n}();\nexport { RecognizerEngine };","map":{"version":3,"names":["cloneArr","cloneObj","every","flatten","has","isArray","isEmpty","isObject","reduce","uniq","values","AT_LEAST_ONE_IDX","AT_LEAST_ONE_SEP_IDX","BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","MANY_IDX","MANY_SEP_IDX","OPTION_IDX","OR_IDX","isRecognitionException","MismatchedTokenException","NotAllInputParsedException","PROD_TYPE","NextTerminalAfterAtLeastOneSepWalker","NextTerminalAfterAtLeastOneWalker","NextTerminalAfterManySepWalker","NextTerminalAfterManyWalker","DEFAULT_RULE_CONFIG","IN_RULE_RECOVERY_EXCEPTION","EOF","augmentTokenTypes","isTokenType","tokenStructuredMatcher","tokenStructuredMatcherNoCategories","classNameFromInstance","RecognizerEngine","prototype","initRecognizerEngine","tokenVocabulary","config","className","shortRuleNameToFull","fullRuleNameToShort","ruleShortNameIdx","tokenMatcher","definedRulesNames","tokensMap","allRuleNames","isBackTrackingStack","RULE_STACK","RULE_OCCURRENCE_STACK","gastProductionsCache","Error","startOffset","acc","tokType","name","modes","allTokenTypes","uniqueTokens","noTokenCategoriesUsed","tokenConstructor","categoryMatches","defineRule","ruleName","impl","selfAnalysisDone","resyncEnabled","recoveryValueFunc","shortName","invokeRuleWithTry","args","outputCst","apply","cst","CST_STACK","length","cstPostRule","e","invokeRuleCatch","ruleFinallyStateUpdate","wrappedGrammarRule","idxInCallingRule","ruleInvocationStateUpdate","call","ruleNamePropName","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","isBackTracking","recoveryEnabled","recogError","reSyncTokType","findReSyncTokenType","isInCurrentRuleReSyncSet","resyncedTokens","reSyncTo","partialCstResult","recoveredNode","moveToTerminatedState","optionInternal","actionORMethodDef","occurrence","key","getKeyForAutomaticLookahead","nestedName","nestedRuleBeforeClause","optionInternalLogic","undefined","nestedRuleFinallyClause","optionInternalNoCst","_this","lookAheadFunc","getLaFuncFromCache","action","predicate","DEF","GATE","orgLookaheadFunction_1","atLeastOneInternal","prodOccurrence","laKey","atLeastOneInternalLogic","atLeastOneInternalNoCst","orgLookaheadFunction_2","notStuck","doSingleRepetition","raiseEarlyExitException","REPETITION_MANDATORY","ERR_MSG","attemptInRepetitionRecovery","atLeastOneSepFirstInternal","options","atLeastOneSepFirstInternalLogic","atLeastOneSepFirstInternalNoCst","separator","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","LA","CONSUME","repetitionSepSecondInternal","REPETITION_MANDATORY_WITH_SEPARATOR","manyInternal","manyInternalLogic","manyInternalNoCst","lookaheadFunction","orgLookaheadFunction_3","manySepFirstInternal","manySepFirstInternalLogic","manySepFirstInternalNoCst","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","getLexerPosition","afterIteration","orInternalNoCst","altsOrOpts","alts","laFunc","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","orInternal","nestedAltBeforeClauseResult","nestedAltBeforeClause","pop","cstFinallyStateUpdate","isAtEndOfInput","firstRedundantTok","errMsg","errorMessageProvider","buildNotAllInputParsedMessage","firstRedundant","getCurrRuleFullName","SAVE_ERROR","subruleInternal","ruleToCall","idx","ruleResult","ARGS","cstPostNonTerminal","LABEL","subruleInternalError","consumeInternal","consumedToken","nextToken","consumeToken","consumeInternalError","eFromConsumption","consumeInternalRecovery","cstPostTerminal","msg","previousToken","buildMismatchTokenMessage","expected","actual","previous","follows","getFollowsForInRuleRecovery","tryInRuleRecovery","eFromInRuleRecovery","saveRecogState","savedErrors","errors","savedRuleStack","lexerState","exportLexerState","LAST_EXPLICIT_RULE_STACK","reloadRecogState","newState","importLexerState","fullName","push","cstInvocationStateUpdate","getLastExplicitRuleShortName","shortRuleNameToFullName","reset","resetLexerState"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js"],"sourcesContent":["import { cloneArr, cloneObj, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values } from \"../../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../../grammar/keys\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException } from \"../../exceptions_public\";\nimport { PROD_TYPE } from \"../../grammar/lookahead\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker } from \"../../grammar/interpreter\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\";\nimport { EOF } from \"../../../scan/tokens_public\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../../scan/tokens\";\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = classNameFromInstance(this);\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.allRuleNames = [];\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (isArray(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (has(tokenVocabulary, \"modes\") &&\n            every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            var allTokenTypes = flatten(values(tokenVocabulary.modes));\n            var uniqueTokens = uniq(allTokenTypes);\n            this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (isObject(tokenVocabulary)) {\n            this.tokensMap = cloneObj(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        /* tslint:disable */\n        this.tokensMap[\"EOF\"] = EOF;\n        // TODO: This check may not be accurate for multi mode lexers\n        var noTokenCategoriesUsed = every(values(tokenVocabulary), function (tokenConstructor) { return isEmpty(tokenConstructor.categoryMatches); });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes(values(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = has(config, \"resyncEnabled\")\n            ? config.resyncEnabled\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        var recoveryValueFunc = has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        /* tslint:disable */\n        var shortName = this.ruleShortNameIdx <<\n            (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        /* tslint:enable */\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        function invokeRuleWithTry(args) {\n            try {\n                if (this.outputCst === true) {\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                else {\n                    return impl.apply(this, args);\n                }\n            }\n            catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            }\n            finally {\n                this.ruleFinallyStateUpdate();\n            }\n        }\n        var wrappedGrammarRule;\n        wrappedGrammarRule = function (idxInCallingRule, args) {\n            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }\n            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n            return invokeRuleWithTry.call(this, args);\n        };\n        var ruleNamePropName = \"ruleName\";\n        wrappedGrammarRule[ruleNamePropName] = ruleName;\n        wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig &&\n            !this.isBackTracking() &&\n            this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);\n        try {\n            return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(key, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_1.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n        try {\n            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n        var key = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_2.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(options, laKey);\n        try {\n            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n        try {\n            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_3.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(options, laKey);\n        try {\n            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {\n        var alts = isArray(altsOrOpts)\n            ? altsOrOpts\n            : altsOrOpts.DEF;\n        var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);\n        try {\n            var alts = isArray(altsOrOpts)\n                ? altsOrOpts\n                : altsOrOpts.DEF;\n            var laFunc = this.getLaFuncFromCache(laKey);\n            var altIdxToTake = laFunc.call(this, alts);\n            if (altIdxToTake !== undefined) {\n                var chosenAlternative = alts[altIdxToTake];\n                var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, OR_IDX, altIdxToTake);\n                try {\n                    return chosenAlternative.ALT.call(this);\n                }\n                finally {\n                    if (nestedAltBeforeClauseResult !== undefined) {\n                        this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);\n                    }\n                }\n            }\n            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            ruleResult = ruleToCall.call(this, idx, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = cloneArr(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n            LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName, shortName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), EOF);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        this.LAST_EXPLICIT_RULE_STACK = [];\n        // TODO: extract a specific rest for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\nexport { RecognizerEngine };\n//# sourceMappingURL=recognizer_engine.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}