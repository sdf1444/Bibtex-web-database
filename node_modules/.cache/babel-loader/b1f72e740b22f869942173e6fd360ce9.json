{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Flat, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof Option) {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition) {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation) {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = every(alts, function (currAlt) {\n    return every(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  });\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = map(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = map(alts, function (currAlt) {\n      return flatten(currAlt);\n    });\n    var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n      forEach(currAlt, function (currTokType) {\n        if (!has(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          if (!has(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, []);\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = every(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length;\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = flatten(alt);\n    if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        }\n        // found a full path that matches.\n        return true;\n      }\n      // none of the paths matched\n      return false;\n    };\n  }\n}\nvar RestDefinitionFinderWalker = /** @class */function (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false;\n  };\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n  return RestDefinitionFinderWalker;\n}(RestWalker);\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */function (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n  return InsideDefinitionFinderVisitor;\n}(GAstVisitor);\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys = longerKeys;\n  }\n  return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = map(altsDefs, function (currAlt) {\n    return possiblePathsFrom([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = map(partialAlts, function (currAltPaths) {\n    var dict = {};\n    forEach(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      forEach(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts;\n  // maxLookahead loop\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n    var _loop_1 = function _loop_1(altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx];\n      // paths in current alternative loop\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx];\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            // Update all new  keys for the current path.\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    };\n    // alternatives loop\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n  return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new Flat({\n    definition: insideDef\n  });\n  var afterFlat = new Flat({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every(lookAheadPaths, function (singleAltPaths) {\n    return every(singleAltPaths, function (singlePath) {\n      return every(singlePath, function (token) {\n        return isEmpty(token.categoryMatches);\n      });\n    });\n  });\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","map","reduce","every","isEmpty","flatten","forEach","has","possiblePathsFrom","RestWalker","tokenStructuredMatcher","tokenStructuredMatcherNoCategories","Alternation","Flat","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","GAstVisitor","PROD_TYPE","getProdType","prod","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","Error","buildLookaheadFuncForOr","occurrence","ruleGrammar","maxLookahead","hasPredicates","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","tokenMatcher","areTokenCategoriesNotUsed","buildLookaheadFuncForOptionalProd","k","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","numOfAlts","length","areAllOneTokenLookahead","currAlt","currPath","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","undefined","call","nextPath","j","currPathLength","i","nextToken","LA","singleTokenAlts","choiceToAlt_1","result","idx","currTokType","tokenTypeIdx","categoryMatches","currExtendingType","buildSingleAlternativeLookaheadFunction","alt","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey_1","choiceToAlt_2","RestDefinitionFinderWalker","_super","topProd","targetOccurrence","targetProdType","_this","startWalking","walk","restDef","checkIsTarget","node","expectedProdType","currRest","prevRest","concat","walkOption","optionProd","walkAtLeastOne","atLeastOneProd","walkAtLeastOneSep","atLeastOneSepProd","walkMany","manyProd","walkManySep","manySepProd","InsideDefinitionFinderVisitor","targetRef","expectedProdName","definition","visitOption","visitRepetition","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitAlternation","initializeArrayOfArrays","size","pathToHashKeys","path","keys","tokType","longerKeys","currShorterKey","push","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","currAltPaths","dict","item","partialPath","currKey","newData","pathLength","currDataset","_loop_1","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","suffixDef","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","key","orProd","visitor","accept","insideDefVisitor","insideDef","afterDefWalker","afterDef","insideFlat","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","categoryMatchesMap","isStrictPrefixOfPath","prefix","other","otherTokType","singleAltPaths","singlePath","token"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Flat, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = every(alts, function (currAlt) {\n        return every(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = map(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined &&\n                    currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = map(alts, function (currAlt) {\n            return flatten(currAlt);\n        });\n        var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n            forEach(currAlt, function (currTokType) {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = every(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = map(altsDefs, function (currAlt) { return possiblePathsFrom([currAlt], 1); });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = map(partialAlts, function (currAltPaths) {\n        var dict = {};\n        forEach(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            forEach(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique ||\n                    isEmpty(suffixDef) ||\n                    currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new Flat({ definition: insideDef });\n    var afterFlat = new Flat({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !==\n                    undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, function (singleAltPaths) {\n        return every(singleAltPaths, function (singlePath) {\n            return every(singlePath, function (token) { return isEmpty(token.categoryMatches); });\n        });\n    });\n}\n//# sourceMappingURL=lookahead.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}