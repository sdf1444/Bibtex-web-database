{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, groupBy, isEmpty, map, pick, reduce, reject, values } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { NamedDSLMethodsCollectorVisitor } from \"../cst/cst\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = [];\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tokenNameErrors = utils.map(tokenTypes, function (currTokType) {\n    return validateTokenName(currTokType, errMsgProvider);\n  });\n  var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);\n  var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);\n  var tooManyAltsErrors = map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var ruleNameErrors = map(topLevels, function (curRule) {\n    return validateRuleName(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError));\n}\nfunction validateNestedRulesNames(topLevels, errMsgProvider) {\n  var result = [];\n  forEach(topLevels, function (curTopLevel) {\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n    curTopLevel.accept(namedCollectorVisitor);\n    var nestedProds = map(namedCollectorVisitor.result, function (currItem) {\n      return currItem.orgProd;\n    });\n    result.push(map(nestedProds, function (currNestedProd) {\n      return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);\n    }));\n  });\n  return flatten(result);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n  return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(GAstVisitor);\nexport { OccurrenceValidationCollector };\nexport var validTermsPattern = /^[a-zA-Z_]\\w*$/;\nexport var validNestedRuleName = new RegExp(validTermsPattern.source.replace(\"^\", \"^\\\\$\"));\n// TODO: remove this limitation now that we use recorders\nexport function validateRuleName(rule, errMsgProvider) {\n  var errors = [];\n  var ruleName = rule.name;\n  if (!ruleName.match(validTermsPattern)) {\n    errors.push({\n      message: errMsgProvider.buildInvalidRuleNameError({\n        topLevelRule: rule,\n        expectedPattern: validTermsPattern\n      }),\n      type: ParserDefinitionErrorType.INVALID_RULE_NAME,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\n// TODO: did the nested rule name regExp now change?\nexport function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {\n  var errors = [];\n  var errMsg;\n  if (!nestedProd.name.match(validNestedRuleName)) {\n    errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,\n      ruleName: topLevel.name\n    });\n  }\n  return errors;\n}\n// TODO: remove this limitation now that we use recorders\nexport function validateTokenName(tokenType, errMsgProvider) {\n  var errors = [];\n  var tokTypeName = tokenType.name;\n  if (!tokTypeName.match(validTermsPattern)) {\n    errors.push({\n      message: errMsgProvider.buildTokenNameError({\n        tokenType: tokenType,\n        expectedPattern: validTermsPattern\n      }),\n      type: ParserDefinitionErrorType.INVALID_TOKEN_NAME\n    });\n  }\n  return errors;\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  var result = [];\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof Flat || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(GAstVisitor);\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // TODO: this filtering should be deprecated once we remove the ignoredIssues\n  //  IParserConfig property\n  var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];\n  if (ignoredIssuesForCurrentRule) {\n    ors = reject(ors, function (currOr) {\n      return ignoredIssuesForCurrentRule[getProductionDslName(currOr) + (currOr.idx === 0 ? \"\" : currOr.idx)];\n    });\n  }\n  // New Handling of ignoring ambiguities\n  // - https://github.com/SAP/chevrotain/issues/869\n  ors = reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\nvar RepetionCollector = /** @class */function (_super) {\n  __extends(RepetionCollector, _super);\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetionCollector;\n}(GAstVisitor);\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n    return errors;\n  }, []);\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, function (currProd) {\n      var prodType = getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = [];\n  // flatten\n  var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if (contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}\nfunction validateDuplicateNestedRules(topLevelRules, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n    currTopRule.accept(namedCollectorVisitor);\n    var prodsByGroup = groupBy(namedCollectorVisitor.result, function (item) {\n      return item.name;\n    });\n    var duplicates = pick(prodsByGroup, function (currGroup) {\n      return currGroup.length > 1;\n    });\n    forEach(values(duplicates), function (currDupGroup) {\n      var currDupProds = map(currDupGroup, function (dupGroup) {\n        return dupGroup.orgProd;\n      });\n      var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,\n        ruleName: currTopRule.name\n      });\n    });\n  });\n  return errors;\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","utils","contains","every","findAll","flatten","forEach","groupBy","isEmpty","map","pick","reduce","reject","values","ParserDefinitionErrorType","getProductionDslName","isOptionalProd","containsPath","getLookaheadPathsForOptionalProd","getLookaheadPathsForOr","getProdType","isStrictPrefixOfPath","NamedDSLMethodsCollectorVisitor","nextPossibleTokensAfter","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","GAstVisitor","validateGrammar","topLevels","globalMaxLookahead","tokenTypes","ignoredIssues","errMsgProvider","grammarName","duplicateErrors","currTopLevel","validateDuplicateProductions","leftRecursionErrors","currTopRule","validateNoLeftRecursion","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateEmptyOrAlternative","validateAmbiguousAlternationAlternatives","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tokenNameErrors","currTokType","validateTokenName","nestedRulesNameErrors","validateNestedRulesNames","nestedRulesDuplicateErrors","validateDuplicateNestedRules","tooManyAltsErrors","curRule","validateTooManyAlts","ruleNameErrors","validateRuleName","duplicateRulesError","validateRuleDoesNotAlreadyExist","concat","result","curTopLevel","namedCollectorVisitor","accept","nestedProds","currItem","orgProd","push","currNestedProd","validateNestedRuleName","topLevelRule","collectorVisitor","OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","defError","message","type","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","terminalType","nonTerminalName","_super","_this","apply","arguments","visitNonTerminal","subrule","visitOption","option","visitRepetitionWithSeparator","manySep","visitRepetitionMandatory","atLeastOne","visitRepetitionMandatoryWithSeparator","atLeastOneSep","visitRepetition","many","visitAlternation","or","visitTerminal","terminal","validTermsPattern","validNestedRuleName","RegExp","source","replace","rule","match","buildInvalidRuleNameError","expectedPattern","INVALID_RULE_NAME","topLevel","nestedProd","errMsg","buildInvalidNestedRuleNameError","INVALID_NESTED_RULE_NAME","tokenType","tokTypeName","buildTokenNameError","INVALID_TOKEN_NAME","allRules","className","occurrences","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","drop","OrCollector","alternations","node","orCollector","ors","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","ignoredIssuesForCurrentRule","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE","prodsByGroup","item","currDupGroup","currDupProds","dupGroup","buildDuplicateNestedRuleNameError","DUPLICATE_NESTED_NAME"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, groupBy, isEmpty, map, pick, reduce, reject, values } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { NamedDSLMethodsCollectorVisitor } from \"../cst/cst\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {\n    var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if (every(leftRecursionErrors, isEmpty)) {\n        emptyAltErrors = map(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tokenNameErrors = utils.map(tokenTypes, function (currTokType) {\n        return validateTokenName(currTokType, errMsgProvider);\n    });\n    var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);\n    var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);\n    var tooManyAltsErrors = map(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var ruleNameErrors = map(topLevels, function (curRule) {\n        return validateRuleName(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = map(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (utils.flatten(duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));\n}\nfunction validateNestedRulesNames(topLevels, errMsgProvider) {\n    var result = [];\n    forEach(topLevels, function (curTopLevel) {\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n        curTopLevel.accept(namedCollectorVisitor);\n        var nestedProds = map(namedCollectorVisitor.result, function (currItem) { return currItem.orgProd; });\n        result.push(map(nestedProds, function (currNestedProd) {\n            return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);\n        }));\n    });\n    return flatten(result);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = utils.pick(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n        var firstProd = utils.first(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = getProductionDslName(firstProd);\n        var defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(GAstVisitor));\nexport { OccurrenceValidationCollector };\nexport var validTermsPattern = /^[a-zA-Z_]\\w*$/;\nexport var validNestedRuleName = new RegExp(validTermsPattern.source.replace(\"^\", \"^\\\\$\"));\n// TODO: remove this limitation now that we use recorders\nexport function validateRuleName(rule, errMsgProvider) {\n    var errors = [];\n    var ruleName = rule.name;\n    if (!ruleName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildInvalidRuleNameError({\n                topLevelRule: rule,\n                expectedPattern: validTermsPattern\n            }),\n            type: ParserDefinitionErrorType.INVALID_RULE_NAME,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\n// TODO: did the nested rule name regExp now change?\nexport function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {\n    var errors = [];\n    var errMsg;\n    if (!nestedProd.name.match(validNestedRuleName)) {\n        errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,\n            ruleName: topLevel.name\n        });\n    }\n    return errors;\n}\n// TODO: remove this limitation now that we use recorders\nexport function validateTokenName(tokenType, errMsgProvider) {\n    var errors = [];\n    var tokTypeName = tokenType.name;\n    if (!tokTypeName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildTokenNameError({\n                tokenType: tokenType,\n                expectedPattern: validTermsPattern\n            }),\n            type: ParserDefinitionErrorType.INVALID_TOKEN_NAME\n        });\n    }\n    return errors;\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!utils.contains(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (utils.isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n            var newPath = utils.cloneArr(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(utils.flatten(errorsFromNextSteps));\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    var result = [];\n    if (utils.isEmpty(definition)) {\n        return result;\n    }\n    var firstProd = utils.first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof Flat ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = isOptionalProd(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = utils.drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(GAstVisitor));\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        var exceptLast = utils.dropRight(currOr.definition);\n        var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n            if (utils.isEmpty(possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(utils.compact(currErrors));\n    }, []);\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // TODO: this filtering should be deprecated once we remove the ignoredIssues\n    //  IParserConfig property\n    var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];\n    if (ignoredIssuesForCurrentRule) {\n        ors = reject(ors, function (currOr) {\n            return ignoredIssuesForCurrentRule[getProductionDslName(currOr) +\n                (currOr.idx === 0 ? \"\" : currOr.idx)];\n        });\n    }\n    // New Handling of ignoring ambiguities\n    // - https://github.com/SAP/chevrotain/issues/869\n    ors = reject(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = utils.reduce(ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(GAstVisitor));\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, function (currProd) {\n            var prodType = getProdType(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx]\n                        .ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = map(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    forEach(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx]\n                .ignoreAmbiguities !== true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = map(tokenTypes, function (currToken) { return currToken.name; });\n    forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (contains(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\nfunction validateDuplicateNestedRules(topLevelRules, errMsgProvider) {\n    var errors = [];\n    forEach(topLevelRules, function (currTopRule) {\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n        currTopRule.accept(namedCollectorVisitor);\n        var prodsByGroup = groupBy(namedCollectorVisitor.result, function (item) { return item.name; });\n        var duplicates = pick(prodsByGroup, function (currGroup) {\n            return currGroup.length > 1;\n        });\n        forEach(values(duplicates), function (currDupGroup) {\n            var currDupProds = map(currDupGroup, function (dupGroup) { return dupGroup.orgProd; });\n            var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,\n                ruleName: currTopRule.name\n            });\n        });\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}