{"ast":null,"code":"import { forEach, map } from \"../utils/utils\";\nimport { RepetitionMandatory, Option, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, NonTerminal, Alternation, Flat, Repetition } from \"../parse/grammar/gast/gast_public\";\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\nvar NL = \"\\n\";\nexport function genUmdModule(options) {\n  return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nexport function genWrapperFunction(options) {\n  return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nexport function genClass(options) {\n  // TODO: how to pass the token vocabulary? Constructor? other?\n  var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n  return result;\n}\nexport function genAllRules(rules) {\n  var rulesText = map(rules, function (currRule) {\n    return genRule(currRule, 1);\n  });\n  return rulesText.join(\"\\n\");\n}\nexport function genRule(prod, n) {\n  var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n  result += genDefinition(prod.definition, n + 1);\n  result += indent(n + 1, \"})\") + NL;\n  return result;\n}\nexport function genTerminal(prod, n) {\n  var name = prod.terminalType.name;\n  // TODO: potential performance optimization, avoid tokenMap Dictionary access\n  return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nexport function genNonTerminal(prod, n) {\n  return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nexport function genAlternation(prod, n) {\n  var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n  var alts = map(prod.definition, function (altDef) {\n    return genSingleAlt(altDef, n + 1);\n  });\n  result += alts.join(\",\" + NL);\n  result += NL + indent(n, \"])\" + NL);\n  return result;\n}\nexport function genSingleAlt(prod, n) {\n  var result = indent(n, \"{\") + NL;\n  if (prod.name) {\n    result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\",\") + NL;\n  }\n  result += indent(n + 1, \"ALT: function() {\") + NL;\n  result += genDefinition(prod.definition, n + 1);\n  result += indent(n + 1, \"}\") + NL;\n  result += indent(n, \"}\");\n  return result;\n}\nfunction genProd(prod, n) {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return genNonTerminal(prod, n);\n  } else if (prod instanceof Option) {\n    return genDSLRule(\"OPTION\", prod, n);\n  } else if (prod instanceof RepetitionMandatory) {\n    return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return genDSLRule(\"MANY_SEP\", prod, n);\n  } else if (prod instanceof Repetition) {\n    return genDSLRule(\"MANY\", prod, n);\n  } else if (prod instanceof Alternation) {\n    return genAlternation(prod, n);\n  } else if (prod instanceof Terminal) {\n    return genTerminal(prod, n);\n  } else if (prod instanceof Flat) {\n    return genDefinition(prod.definition, n);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction genDSLRule(dslName, prod, n) {\n  var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n  if (prod.name || prod.separator) {\n    result += \"{\" + NL;\n    if (prod.name) {\n      result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\"\") + \",\" + NL;\n    }\n    if (prod.separator) {\n      result += indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) + \",\" + NL;\n    }\n    result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n    result += indent(n, \"}\") + NL;\n  } else {\n    result += genDefFunction(prod.definition, n + 1);\n  }\n  result += indent(n, \")\") + NL;\n  return result;\n}\nfunction genDefFunction(definition, n) {\n  var def = \"function() {\" + NL;\n  def += genDefinition(definition, n);\n  def += indent(n, \"}\") + NL;\n  return def;\n}\nfunction genDefinition(def, n) {\n  var result = \"\";\n  forEach(def, function (prod) {\n    result += genProd(prod, n + 1);\n  });\n  return result;\n}\nfunction indent(howMuch, text) {\n  var spaces = Array(howMuch * 4 + 1).join(\" \");\n  return spaces + text;\n}","map":{"version":3,"names":["forEach","map","RepetitionMandatory","Option","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","NonTerminal","Alternation","Flat","Repetition","NL","genUmdModule","options","genClass","name","genWrapperFunction","result","genAllRules","rules","rulesText","currRule","genRule","join","prod","n","indent","genDefinition","definition","genTerminal","terminalType","idx","genNonTerminal","nonTerminalName","genAlternation","alts","altDef","genSingleAlt","genProd","genDSLRule","Error","dslName","separator","genDefFunction","def","howMuch","text","spaces","Array"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/generate/generate.js"],"sourcesContent":["import { forEach, map } from \"../utils/utils\";\nimport { RepetitionMandatory, Option, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, NonTerminal, Alternation, Flat, Repetition } from \"../parse/grammar/gast/gast_public\";\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\nvar NL = \"\\n\";\nexport function genUmdModule(options) {\n    return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nexport function genWrapperFunction(options) {\n    return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nexport function genClass(options) {\n    // TODO: how to pass the token vocabulary? Constructor? other?\n    var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n    return result;\n}\nexport function genAllRules(rules) {\n    var rulesText = map(rules, function (currRule) {\n        return genRule(currRule, 1);\n    });\n    return rulesText.join(\"\\n\");\n}\nexport function genRule(prod, n) {\n    var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"})\") + NL;\n    return result;\n}\nexport function genTerminal(prod, n) {\n    var name = prod.terminalType.name;\n    // TODO: potential performance optimization, avoid tokenMap Dictionary access\n    return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nexport function genNonTerminal(prod, n) {\n    return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nexport function genAlternation(prod, n) {\n    var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n    var alts = map(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });\n    result += alts.join(\",\" + NL);\n    result += NL + indent(n, \"])\" + NL);\n    return result;\n}\nexport function genSingleAlt(prod, n) {\n    var result = indent(n, \"{\") + NL;\n    if (prod.name) {\n        result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\",\") + NL;\n    }\n    result += indent(n + 1, \"ALT: function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"}\") + NL;\n    result += indent(n, \"}\");\n    return result;\n}\nfunction genProd(prod, n) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return genNonTerminal(prod, n);\n    }\n    else if (prod instanceof Option) {\n        return genDSLRule(\"OPTION\", prod, n);\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return genDSLRule(\"MANY_SEP\", prod, n);\n    }\n    else if (prod instanceof Repetition) {\n        return genDSLRule(\"MANY\", prod, n);\n    }\n    else if (prod instanceof Alternation) {\n        return genAlternation(prod, n);\n    }\n    else if (prod instanceof Terminal) {\n        return genTerminal(prod, n);\n    }\n    else if (prod instanceof Flat) {\n        return genDefinition(prod.definition, n);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction genDSLRule(dslName, prod, n) {\n    var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n    if (prod.name || prod.separator) {\n        result += \"{\" + NL;\n        if (prod.name) {\n            result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\"\") + \",\" + NL;\n        }\n        if (prod.separator) {\n            result +=\n                indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) +\n                    \",\" +\n                    NL;\n        }\n        result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n        result += indent(n, \"}\") + NL;\n    }\n    else {\n        result += genDefFunction(prod.definition, n + 1);\n    }\n    result += indent(n, \")\") + NL;\n    return result;\n}\nfunction genDefFunction(definition, n) {\n    var def = \"function() {\" + NL;\n    def += genDefinition(definition, n);\n    def += indent(n, \"}\") + NL;\n    return def;\n}\nfunction genDefinition(def, n) {\n    var result = \"\";\n    forEach(def, function (prod) {\n        result += genProd(prod, n + 1);\n    });\n    return result;\n}\nfunction indent(howMuch, text) {\n    var spaces = Array(howMuch * 4 + 1).join(\" \");\n    return spaces + text;\n}\n//# sourceMappingURL=generate.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}