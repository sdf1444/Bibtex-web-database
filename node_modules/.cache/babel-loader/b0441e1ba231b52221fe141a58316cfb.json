{"ast":null,"code":"// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nexport var BITS_FOR_METHOD_TYPE = 4;\nexport var BITS_FOR_OCCURRENCE_IDX = 8;\nexport var BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport var BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n/* tslint:disable */\nexport var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n/* tslint:enable */\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n  /* tslint:disable */\n  return occurrence | dslMethodIdx | ruleIdx;\n  /* tslint:enable */\n}\n\nvar BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\nexport function getKeyForAltIndex(ruleIdx, dslMethodIdx, occurrence, altIdx) {\n  /* tslint:disable */\n  // alternative indices are zero based, thus must always add one (turn on one bit) to guarantee uniqueness.\n  var altIdxBitMap = altIdx + 1 << BITS_START_FOR_ALT_IDX;\n  return getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) | altIdxBitMap;\n  /* tslint:enable */\n}","map":{"version":3,"names":["BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","BITS_FOR_RULE_IDX","BITS_FOR_ALT_IDX","OR_IDX","OPTION_IDX","MANY_IDX","AT_LEAST_ONE_IDX","MANY_SEP_IDX","AT_LEAST_ONE_SEP_IDX","getKeyForAutomaticLookahead","ruleIdx","dslMethodIdx","occurrence","BITS_START_FOR_ALT_IDX","getKeyForAltIndex","altIdx","altIdxBitMap"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js"],"sourcesContent":["// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nexport var BITS_FOR_METHOD_TYPE = 4;\nexport var BITS_FOR_OCCURRENCE_IDX = 8;\nexport var BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport var BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n/* tslint:disable */\nexport var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n/* tslint:enable */\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    /* tslint:disable */\n    return occurrence | dslMethodIdx | ruleIdx;\n    /* tslint:enable */\n}\nvar BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\nexport function getKeyForAltIndex(ruleIdx, dslMethodIdx, occurrence, altIdx) {\n    /* tslint:disable */\n    // alternative indices are zero based, thus must always add one (turn on one bit) to guarantee uniqueness.\n    var altIdxBitMap = (altIdx + 1) << BITS_START_FOR_ALT_IDX;\n    return (getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) |\n        altIdxBitMap);\n    /* tslint:enable */\n}\n//# sourceMappingURL=keys.js.map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIA,oBAAoB,GAAG,CAAC;AACnC,OAAO,IAAIC,uBAAuB,GAAG,CAAC;AACtC,OAAO,IAAIC,iBAAiB,GAAG,EAAE;AACjC;AACA,OAAO,IAAIC,gBAAgB,GAAG,CAAC;AAC/B;AACA;AACA;AACA;AACA,OAAO,IAAIC,MAAM,GAAG,CAAC,IAAIH,uBAAuB;AAChD,OAAO,IAAII,UAAU,GAAG,CAAC,IAAIJ,uBAAuB;AACpD,OAAO,IAAIK,QAAQ,GAAG,CAAC,IAAIL,uBAAuB;AAClD,OAAO,IAAIM,gBAAgB,GAAG,CAAC,IAAIN,uBAAuB;AAC1D,OAAO,IAAIO,YAAY,GAAG,CAAC,IAAIP,uBAAuB;AACtD,OAAO,IAAIQ,oBAAoB,GAAG,CAAC,IAAIR,uBAAuB;AAC9D;AACA;AACA,OAAO,SAASS,2BAA2B,CAACC,OAAO,EAAEC,YAAY,EAAEC,UAAU,EAAE;EAC3E;EACA,OAAOA,UAAU,GAAGD,YAAY,GAAGD,OAAO;EAC1C;AACJ;;AACA,IAAIG,sBAAsB,GAAG,EAAE,GAAGX,gBAAgB;AAClD,OAAO,SAASY,iBAAiB,CAACJ,OAAO,EAAEC,YAAY,EAAEC,UAAU,EAAEG,MAAM,EAAE;EACzE;EACA;EACA,IAAIC,YAAY,GAAID,MAAM,GAAG,CAAC,IAAKF,sBAAsB;EACzD,OAAQJ,2BAA2B,CAACC,OAAO,EAAEC,YAAY,EAAEC,UAAU,CAAC,GAClEI,YAAY;EAChB;AACJ"},"metadata":{},"sourceType":"module"}