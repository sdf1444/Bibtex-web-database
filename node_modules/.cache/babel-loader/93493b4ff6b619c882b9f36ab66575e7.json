{"ast":null,"code":"import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */function () {\n  function RestWalker() {}\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n    forEach(prod.definition, function (subProd, index) {\n      var currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Flat) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this;\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    var fullOrRest = currRest.concat(prevRest);\n    // walk all different alternatives\n    forEach(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new Flat({\n        definition: [alt]\n      });\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n  return RestWalker;\n}();\nexport { RestWalker };\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new Option({\n    definition: [new Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"names":["drop","forEach","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","RestWalker","prototype","walk","prod","prevRest","_this","definition","subProd","index","currRest","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","Error","terminal","refProd","flatProd","fullOrRest","concat","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","repSepRest","terminalType","separator","fullRepSepRest"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js"],"sourcesContent":["import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        forEach(prod.definition, function (subProd, index) {\n            var currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Flat) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new Flat({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\nexport { RestWalker };\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator })\n            ].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}