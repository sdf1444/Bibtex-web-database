{"ast":null,"code":"import { forEach, has, isArray, isFunction, peek, some } from \"../../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"../../grammar/gast/gast_public\";\nimport { Lexer } from \"../../../scan/lexer_public\";\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\";\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\";\nimport { END_OF_FILE } from \"../parser\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\";\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: Lexer.NA\n});\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */function () {\n  function GastRecorder() {}\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function _loop_1(i) {\n        var idx = i > 0 ? i : \"\";\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      }\n      // DSL methods with the idx(suffix) as an argument\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n    this.RECORDING_PHASE = false;\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  };\n  // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  };\n  // Executing backtracking logic will break our recording logic assumptions\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  };\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE;\n  };\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  };\n  // Implementation of parsing DSL\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    var prevProd = peek(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!hasShortKeyProperty(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    var prevProd = peek(this.recordingProdStack);\n    var newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n  return GastRecorder;\n}();\nexport { GastRecorder };\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = peek(this.recordingProdStack);\n  var grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n  if (has(mainProdArg, \"NAME\")) {\n    newProd.name = mainProdArg.NAME;\n  }\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = peek(this.recordingProdStack);\n  // Only an array of alternatives\n  var hasOptions = isArray(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n  if (has(mainProdArg, \"NAME\")) {\n    newOrProd.name = mainProdArg.NAME;\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  var hasPredicates = some(alts, function (currAlt) {\n    return isFunction(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  forEach(alts, function (currAlt) {\n    var currAltFlat = new Flat({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n    if (has(currAlt, \"NAME\")) {\n      currAltFlat.name = currAlt.NAME;\n    }\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    _this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(_this);\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error(\n    // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"names":["forEach","has","isArray","isFunction","peek","some","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","Lexer","augmentTokenTypes","hasShortKeyProperty","createToken","createTokenInstance","END_OF_FILE","BITS_FOR_OCCURRENCE_IDX","RECORDING_NULL_OBJECT","description","Object","freeze","HANDLE_SEPARATOR","MAX_METHOD_IDX","Math","pow","RFT","name","pattern","NA","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","children","GastRecorder","prototype","initGastRecorder","config","recordingProdStack","RECORDING_PHASE","enableRecording","_this","TRACE_INIT","_loop_1","i","idx","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION","ACTION_RECORD","BACKTRACK","BACKTRACK_RECORD","LA","LA_RECORD","disableRecording","impl","grammarRule","args","howMuch","topLevelRuleRecord","def","newTopLevelRule","definition","push","call","pop","originalError","KNOWN_RECORDER_ERROR","message","mutabilityError","actionORMethodDef","occurrence","recordProd","options","altsOrOpts","recordOrProd","ruleToCall","assertMethodIdxIsValid","error","Error","getIdxSuffix","JSON","stringify","prevProd","ruleName","newNoneTerminal","nonTerminalName","referencedRule","undefined","outputCst","tokType","terminalType","prodConstructor","mainProdArg","handleSep","grammarAction","DEF","newProd","NAME","separator","SEP","maxLookahead","MAX_LOOKAHEAD","hasOptions","alts","newOrProd","ignoreAmbiguities","IGNORE_AMBIGUITIES","hasPredicates","currAlt","GATE","currAltFlat","ALT"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js"],"sourcesContent":["import { forEach, has, isArray, isFunction, peek, some } from \"../../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"../../grammar/gast/gast_public\";\nimport { Lexer } from \"../../../scan/lexer_public\";\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\";\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\";\nimport { END_OF_FILE } from \"../parser\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\";\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\" + idx] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\" + idx] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\" + idx] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\" + idx] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete _this[\"CONSUME\" + idx];\n                delete _this[\"SUBRULE\" + idx];\n                delete _this[\"OPTION\" + idx];\n                delete _this[\"OR\" + idx];\n                delete _this[\"MANY\" + idx];\n                delete _this[\"MANY_SEP\" + idx];\n                delete _this[\"AT_LEAST_ONE\" + idx];\n                delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n            }\n            delete _this[\"consume\"];\n            delete _this[\"subrule\"];\n            delete _this[\"option\"];\n            delete _this[\"or\"];\n            delete _this[\"many\"];\n            delete _this[\"atLeastOne\"];\n            delete _this.ACTION;\n            delete _this.BACKTRACK;\n            delete _this.LA;\n        });\n    };\n    // TODO: is there any way to use this method to check no\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n        return;\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = peek(this.recordingProdStack);\n        var ruleName = ruleToCall[\"ruleName\"];\n        var newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = peek(this.recordingProdStack);\n        var newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\nexport { GastRecorder };\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = peek(this.recordingProdStack);\n    var grammarAction = isFunction(mainProdArg)\n        ? mainProdArg\n        : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (has(mainProdArg, \"NAME\")) {\n        newProd.name = mainProdArg.NAME;\n    }\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = peek(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = isArray(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if (has(mainProdArg, \"NAME\")) {\n        newOrProd.name = mainProdArg.NAME;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = some(alts, function (currAlt) { return isFunction(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    forEach(alts, function (currAlt) {\n        var currAltFlat = new Flat({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"NAME\")) {\n            currAltFlat.name = currAlt.NAME;\n        }\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" +\n            (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX +\n                1)));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}