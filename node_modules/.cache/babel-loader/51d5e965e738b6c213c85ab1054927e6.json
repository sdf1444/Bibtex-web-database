{"ast":null,"code":"import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */function () {\n  function Lexer(lexerDefinition, config) {\n    var _this = this;\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.config = undefined;\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    }\n    // todo: defaults func?\n    this.config = merge(DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: {}\n          };\n          actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n          actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = cloneObj(lexerDefinition);\n        }\n      });\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      }\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) {\n          return isUndefined(currTokType);\n        });\n      });\n      var allModeNames = keys(actualDefinition.modes);\n      forEach(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n          _this.modes.push(currModName);\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          }\n          // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n          if (isEmpty(_this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            var currAnalyzeResult_1;\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT.bind(_this)\n              });\n            });\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n      if (!isEmpty(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          _this.chopInput = IDENTITY;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = NOOP;\n          _this.match = _this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          _this.handleModes = NOOP;\n        }\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = IDENTITY;\n        }\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = NOOP;\n        }\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n        }\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        clearRegExpParserCache();\n      });\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        toFastProperties(_this);\n      });\n    });\n  }\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    var lexResult = this.tokenizeInternal(text, initialMode);\n    return lexResult;\n  };\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n    var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0;\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = cloneEmptyGroups(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns = undefined;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    var pop_mode = function pop_mode(popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 &&\n      // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column: popToken.startColumn !== undefined ? popToken.startColumn : undefined,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = last(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode);\n    var currConfig;\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null;\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        var singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt;\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltConfig = patternIdxToConfig[longerAltIdx];\n            var longerAltPattern = longerAltConfig.pattern;\n            altPayload = null;\n            // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n              if (match !== null) {\n                matchAltImage = match[0];\n                if (match.payload !== undefined) {\n                  altPayload = match.payload;\n                }\n              } else {\n                matchAltImage = null;\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset);\n              matchAltImage = this.match(longerAltPattern, text, offset);\n            }\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage;\n              payload = altPayload;\n              currConfig = longerAltConfig;\n            }\n          }\n          break;\n        }\n      }\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx;\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = false;\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset);\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern;\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            var singleCharCode = currConfig_1.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n      }\n    }\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  };\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT;\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  };\n\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  };\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.createTokenInstance = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return null;\n  };\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n    return 666;\n  };\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  };\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.handlePayload = function (token, payload) {};\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n  Lexer.prototype.match = function (pattern, text, offset) {\n    return null;\n  };\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  };\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : regExpArray;\n  };\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(indent + \"--> <\" + phaseDesc + \">\");\n      }\n      var _a = timer(phaseImpl),\n        time = _a.time,\n        value = _a.value;\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      var traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\nexport { Lexer };","map":{"version":3,"names":["analyzeTokenTypes","charCodeToOptimizedIndex","cloneEmptyGroups","DEFAULT_MODE","LineTerminatorOptimizedTester","performRuntimeChecks","performWarningRuntimeChecks","SUPPORT_STICKY","validatePatterns","cloneArr","cloneObj","forEach","IDENTITY","isArray","isEmpty","isUndefined","keys","last","map","merge","NOOP","PRINT_WARNING","reduce","reject","timer","toFastProperties","augmentTokenTypes","defaultLexerErrorProvider","clearRegExpParserCache","LexerDefinitionErrorType","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","positionTracking","lineTerminatorsPattern","lineTerminatorCharacters","ensureOptimizations","safeMode","errorMessageProvider","traceInitPerf","skipValidations","Object","freeze","Lexer","lexerDefinition","config","_this","lexerDefinitionErrors","lexerDefinitionWarning","patternIdxToConfig","charCodeToPatternIdxToConfig","modes","emptyGroups","undefined","trackStartLines","trackEndLines","hasCustom","canModeBeOptimized","Error","traceInitVal","traceInitMaxIdent","Infinity","traceInitIndent","TRACE_INIT","actualDefinition","hasOnlySingleMode","test","concat","currModeValue","currModeName","currTokType","allModeNames","currModDef","currModName","push","currAnalyzeResult_1","tracer","bind","canBeOptimized","defaultMode","allErrMessages","error","message","allErrMessagesString","join","warningDescriptor","chopInput","match","matchWithTest","updateLastIndex","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","prototype","tokenize","text","initialMode","lexResult","tokenizeInternal","i","j","matchAltImage","longerAltIdx","matchedImage","payload","altPayload","imageLength","group","tokType","newToken","errLength","droppedChar","msg","orgText","orgLength","length","offset","matchedTokensIndex","guessedNumberOfTokens","Math","floor","matchedTokens","Array","errors","line","column","groups","trackLines","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","charCode","optimizedCharIdx","possiblePatterns","pop_mode","popToken","tokenType","PUSH_MODE","msg_1","buildUnableToPopLexerModeMessage","startOffset","startLine","startColumn","image","pop","newMode","modeCanBeOptimized","push_mode","call","currConfig","nextCharCode","charCodeAt","chosenPatternIdxToConfig","chosenPatternsLength","currPattern","pattern","singleCharCode","short","isCustom","exec","longerAlt","longerAltConfig","longerAltPattern","tokenTypeIdx","canLineTerminator","numOfLTsInMatch","foundTerminator","lastLTEndOffset","lastIndex","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig_1","buildUnexpectedCharactersMessage","tokens","pushMode","substring","regExp","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","args","_i","arguments","endOffset","tokenVector","index","tokenToAdd","token","found","regExpArray","phaseDesc","phaseImpl","indent","console","log","_a","time","value","traceMethod","warn","SKIPPED","NA"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/scan/lexer_public.js"],"sourcesContent":["import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        var _this = this;\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.config = undefined;\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = merge(DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (isArray(lexerDefinition)) {\n                    actualDefinition = { modes: {} };\n                    actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n                    actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = cloneObj((lexerDefinition));\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) { return isUndefined(currTokType); });\n            });\n            var allModeNames = keys(actualDefinition.modes);\n            forEach(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (isEmpty(_this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: _this.config\n                                    .lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT.bind(_this)\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom =\n                            currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!isEmpty(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" +\n                    allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    _this.chopInput = IDENTITY;\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = NOOP;\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = NOOP;\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = IDENTITY;\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = NOOP;\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                clearRegExpParserCache();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                toFastProperties(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!isEmpty(this.lexerDefinitionErrors)) {\n            var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        var lexResult = this.tokenizeInternal(text, initialMode);\n        return lexResult;\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = cloneEmptyGroups(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns = undefined;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine !== undefined\n                        ? popToken.startLine\n                        : undefined,\n                    column: popToken.startColumn !== undefined\n                        ? popToken.startColumn\n                        : undefined,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = last(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig = _this\n                    .charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] &&\n                    _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this\n                .charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] &&\n                this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAltIdx = currConfig.longerAlt;\n                    if (longerAltIdx !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltConfig = patternIdxToConfig[longerAltIdx];\n                        var longerAltPattern = longerAltConfig.pattern;\n                        altPayload = null;\n                        // single Char can never be a longer alt so no need to test it.\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        if (longerAltConfig.isCustom === true) {\n                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                            if (match !== null) {\n                                matchAltImage = match[0];\n                                if (match.payload !== undefined) {\n                                    altPayload = match.payload;\n                                }\n                            }\n                            else {\n                                matchAltImage = null;\n                            }\n                        }\n                        else {\n                            this.updateLastIndex(longerAltPattern, offset);\n                            matchAltImage = this.match(longerAltPattern, text, offset);\n                        }\n                        if (matchAltImage &&\n                            matchAltImage.length > matchedImage.length) {\n                            matchedImage = matchAltImage;\n                            payload = altPayload;\n                            currConfig = longerAltConfig;\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true &&\n                    currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset =\n                                lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = false;\n                while (!foundResyncPoint && offset < orgLength) {\n                    // drop chars until we succeed in matching something\n                    droppedChar = orgText.charCodeAt(offset);\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.createTokenInstance = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return null;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n        return 666;\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.handlePayload = function (token, payload) { };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n    Lexer.prototype.match = function (pattern, text, offset) {\n        return null;\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : regExpArray;\n    };\n    // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = timer(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\nexport { Lexer };\n//# sourceMappingURL=lexer_public.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}