{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { forEach, isUndefined } from \"../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAltIndex, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../grammar/keys\";\nimport { Alternation, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"../grammar/gast/gast_public\";\nimport { GAstVisitor } from \"../grammar/gast/gast_visitor_public\";\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\nvar NamedDSLMethodsCollectorVisitor = /** @class */function (_super) {\n  __extends(NamedDSLMethodsCollectorVisitor, _super);\n  function NamedDSLMethodsCollectorVisitor(ruleIdx) {\n    var _this = _super.call(this) || this;\n    _this.result = [];\n    _this.ruleIdx = ruleIdx;\n    return _this;\n  }\n  NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {\n    // TODO: better hack to copy what we need here...\n    if (!isUndefined(node.name)) {\n      // copy without name so this will indeed be processed later.\n      var nameLessNode\n      /* istanbul ignore else */ = void 0;\n      /* istanbul ignore else */\n      if (node instanceof Option || node instanceof Repetition || node instanceof RepetitionMandatory || node instanceof Alternation) {\n        nameLessNode = new newNodeConstructor({\n          definition: node.definition,\n          idx: node.idx\n        });\n      } else if (node instanceof RepetitionMandatoryWithSeparator || node instanceof RepetitionWithSeparator) {\n        nameLessNode = new newNodeConstructor({\n          definition: node.definition,\n          idx: node.idx,\n          separator: node.separator\n        });\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n      var def = [nameLessNode];\n      var key = getKeyForAutomaticLookahead(this.ruleIdx, methodIdx, node.idx);\n      this.result.push({\n        def: def,\n        key: key,\n        name: node.name,\n        orgProd: node\n      });\n    }\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {\n    this.collectNamedDSLMethod(node, Option, OPTION_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {\n    this.collectNamedDSLMethod(node, Repetition, MANY_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionMandatory, AT_LEAST_ONE_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionMandatoryWithSeparator, AT_LEAST_ONE_SEP_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionWithSeparator, MANY_SEP_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {\n    var _this = this;\n    this.collectNamedDSLMethod(node, Alternation, OR_IDX);\n    var hasMoreThanOneAlternative = node.definition.length > 1;\n    forEach(node.definition, function (currFlatAlt, altIdx) {\n      if (!isUndefined(currFlatAlt.name)) {\n        var def = currFlatAlt.definition;\n        if (hasMoreThanOneAlternative) {\n          def = [new Option({\n            definition: currFlatAlt.definition\n          })];\n        } else {\n          // mandatory\n          def = currFlatAlt.definition;\n        }\n        var key = getKeyForAltIndex(_this.ruleIdx, OR_IDX, node.idx, altIdx);\n        _this.result.push({\n          def: def,\n          key: key,\n          name: currFlatAlt.name,\n          orgProd: currFlatAlt\n        });\n      }\n    });\n  };\n  return NamedDSLMethodsCollectorVisitor;\n}(GAstVisitor);\nexport { NamedDSLMethodsCollectorVisitor };\nexport function expandAllNestedRuleNames(topRules, fullToShortName) {\n  var result = {\n    allRuleNames: []\n  };\n  forEach(topRules, function (currTopRule) {\n    var currTopRuleShortName = fullToShortName[currTopRule.name];\n    result.allRuleNames.push(currTopRule.name);\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);\n    currTopRule.accept(namedCollectorVisitor);\n    forEach(namedCollectorVisitor.result, function (_a) {\n      var def = _a.def,\n        key = _a.key,\n        name = _a.name;\n      result.allRuleNames.push(currTopRule.name + name);\n    });\n  });\n  return result;\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","forEach","isUndefined","AT_LEAST_ONE_IDX","AT_LEAST_ONE_SEP_IDX","getKeyForAltIndex","getKeyForAutomaticLookahead","MANY_IDX","MANY_SEP_IDX","OPTION_IDX","OR_IDX","Alternation","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","GAstVisitor","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","startOffset","endOffset","setNodeLocationFull","startColumn","startLine","endColumn","endLine","addTerminalToCst","node","token","tokenTypeName","children","undefined","push","addNoneTerminalToCst","ruleName","ruleResult","NamedDSLMethodsCollectorVisitor","_super","ruleIdx","_this","call","result","collectNamedDSLMethod","newNodeConstructor","methodIdx","name","nameLessNode","definition","idx","separator","Error","def","key","orgProd","visitOption","visitRepetition","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitAlternation","hasMoreThanOneAlternative","length","currFlatAlt","altIdx","expandAllNestedRuleNames","topRules","fullToShortName","allRuleNames","currTopRule","currTopRuleShortName","namedCollectorVisitor","accept","_a"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/cst/cst.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { forEach, isUndefined } from \"../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAltIndex, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../grammar/keys\";\nimport { Alternation, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"../grammar/gast/gast_public\";\nimport { GAstVisitor } from \"../grammar/gast/gast_visitor_public\";\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\nvar NamedDSLMethodsCollectorVisitor = /** @class */ (function (_super) {\n    __extends(NamedDSLMethodsCollectorVisitor, _super);\n    function NamedDSLMethodsCollectorVisitor(ruleIdx) {\n        var _this = _super.call(this) || this;\n        _this.result = [];\n        _this.ruleIdx = ruleIdx;\n        return _this;\n    }\n    NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {\n        // TODO: better hack to copy what we need here...\n        if (!isUndefined(node.name)) {\n            // copy without name so this will indeed be processed later.\n            var nameLessNode \n            /* istanbul ignore else */\n            = void 0;\n            /* istanbul ignore else */\n            if (node instanceof Option ||\n                node instanceof Repetition ||\n                node instanceof RepetitionMandatory ||\n                node instanceof Alternation) {\n                nameLessNode = new newNodeConstructor({\n                    definition: node.definition,\n                    idx: node.idx\n                });\n            }\n            else if (node instanceof RepetitionMandatoryWithSeparator ||\n                node instanceof RepetitionWithSeparator) {\n                nameLessNode = new newNodeConstructor({\n                    definition: node.definition,\n                    idx: node.idx,\n                    separator: node.separator\n                });\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n            var def = [nameLessNode];\n            var key = getKeyForAutomaticLookahead(this.ruleIdx, methodIdx, node.idx);\n            this.result.push({ def: def, key: key, name: node.name, orgProd: node });\n        }\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {\n        this.collectNamedDSLMethod(node, Option, OPTION_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {\n        this.collectNamedDSLMethod(node, Repetition, MANY_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.collectNamedDSLMethod(node, RepetitionMandatory, AT_LEAST_ONE_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.collectNamedDSLMethod(node, RepetitionMandatoryWithSeparator, AT_LEAST_ONE_SEP_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.collectNamedDSLMethod(node, RepetitionWithSeparator, MANY_SEP_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {\n        var _this = this;\n        this.collectNamedDSLMethod(node, Alternation, OR_IDX);\n        var hasMoreThanOneAlternative = node.definition.length > 1;\n        forEach(node.definition, function (currFlatAlt, altIdx) {\n            if (!isUndefined(currFlatAlt.name)) {\n                var def = currFlatAlt.definition;\n                if (hasMoreThanOneAlternative) {\n                    def = [new Option({ definition: currFlatAlt.definition })];\n                }\n                else {\n                    // mandatory\n                    def = currFlatAlt.definition;\n                }\n                var key = getKeyForAltIndex(_this.ruleIdx, OR_IDX, node.idx, altIdx);\n                _this.result.push({\n                    def: def,\n                    key: key,\n                    name: currFlatAlt.name,\n                    orgProd: currFlatAlt\n                });\n            }\n        });\n    };\n    return NamedDSLMethodsCollectorVisitor;\n}(GAstVisitor));\nexport { NamedDSLMethodsCollectorVisitor };\nexport function expandAllNestedRuleNames(topRules, fullToShortName) {\n    var result = {\n        allRuleNames: []\n    };\n    forEach(topRules, function (currTopRule) {\n        var currTopRuleShortName = fullToShortName[currTopRule.name];\n        result.allRuleNames.push(currTopRule.name);\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);\n        currTopRule.accept(namedCollectorVisitor);\n        forEach(namedCollectorVisitor.result, function (_a) {\n            var def = _a.def, key = _a.key, name = _a.name;\n            result.allRuleNames.push(currTopRule.name + name);\n        });\n    });\n    return result;\n}\n//# sourceMappingURL=cst.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}