{"ast":null,"code":"import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n  this.name = IN_RULE_RECOVERY_EXCEPTION;\n  this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */function () {\n  function Recoverable() {}\n  Recoverable.prototype.initRecoverable = function (config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  };\n  Recoverable.prototype.getTokenToInsert = function (tokType) {\n    var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  };\n  Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n    return true;\n  };\n  Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    var _this = this;\n    // TODO: can the resyncTokenType be cached?\n    var reSyncTokType = this.findReSyncTokenType();\n    var savedLexerState = this.exportLexerState();\n    var resyncedTokens = [];\n    var passedResyncPoint = false;\n    var nextTokenWithoutResync = this.LA(1);\n    var currToken = this.LA(1);\n    var generateErrorMessage = function generateErrorMessage() {\n      var previousToken = _this.LA(0);\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: _this.getCurrRuleFullName()\n      });\n      var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = dropRight(resyncedTokens);\n      _this.SAVE_ERROR(error);\n    };\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage();\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState);\n  };\n  Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    }\n    // arguments to try and perform resync into the next iteration of the many are missing\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return false;\n    }\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false;\n    }\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n    return true;\n  };\n  // Error Recovery functionality\n  Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n    var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    var follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  };\n  Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      var tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      var nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  };\n  Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  };\n  Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n    var _this = this;\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n    // must know the possible following tokens to perform single token insertion\n    if (isEmpty(follows)) {\n      return false;\n    }\n    var mismatchedTok = this.LA(1);\n    var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n      return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== undefined;\n    return isMisMatchedTokInFollows;\n  };\n  Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n    var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  };\n  Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n    var followKey = this.getCurrFollowKey();\n    var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return contains(currentRuleReSyncSet, tokenTypeIdx);\n  };\n  Recoverable.prototype.findReSyncTokenType = function () {\n    var allPossibleReSyncTokTypes = this.flattenFollowSet();\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    var nextToken = this.LA(1);\n    var k = 2;\n    while (true) {\n      var nextTokenType = nextToken.tokenType;\n      if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n        return nextTokenType;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  };\n  Recoverable.prototype.getCurrFollowKey = function () {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  };\n  Recoverable.prototype.buildFullFollowKeyStack = function () {\n    var _this = this;\n    var explicitRuleStack = this.RULE_STACK;\n    var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n      explicitRuleStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) {\n        return _this.RULE_STACK[idx];\n      });\n      explicitOccurrenceStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) {\n        return _this.RULE_OCCURRENCE_STACK[idx];\n      });\n    }\n    // TODO: only iterate over explicit rules here\n    return map(explicitRuleStack, function (ruleName, idx) {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: _this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  };\n  Recoverable.prototype.flattenFollowSet = function () {\n    var _this = this;\n    var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n      return _this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten(followStack);\n  };\n  Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n    var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  };\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  };\n  Recoverable.prototype.reSyncTo = function (tokType) {\n    var resyncedTokens = [];\n    var nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    // the last token is not part of the error.\n    return dropRight(resyncedTokens);\n  };\n  Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  };\n  Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n    var pathRuleStack = this.getHumanReadableRuleStack();\n    var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n    var grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  };\n  Recoverable.prototype.getHumanReadableRuleStack = function () {\n    var _this = this;\n    if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n      return map(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {\n        return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);\n      });\n    } else {\n      return map(this.RULE_STACK, function (currShortName) {\n        return _this.shortRuleNameToFullName(currShortName);\n      });\n    }\n  };\n  return Recoverable;\n}();\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  var firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === undefined) {\n    var currRuleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[currRuleName];\n    var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n  var expectTokAfterLastMatch = firstAfterRepInfo.token;\n  var nextTokIdx = firstAfterRepInfo.occurrence;\n  var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}","map":{"version":3,"names":["createTokenInstance","EOF","cloneArr","contains","dropRight","find","flatten","has","isEmpty","map","MismatchedTokenException","IN","DEFAULT_PARSER_CONFIG","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","message","name","prototype","Error","Recoverable","initRecoverable","config","firstAfterRepMap","resyncFollows","recoveryEnabled","attemptInRepetitionRecovery","getTokenToInsert","tokType","tokToInsert","NaN","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","tryInRepetitionRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","_this","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","resyncedTokens","passedResyncPoint","nextTokenWithoutResync","LA","currToken","generateErrorMessage","previousToken","msg","errorMessageProvider","buildMismatchTokenMessage","expected","actual","previous","ruleName","getCurrRuleFullName","error","SAVE_ERROR","tokenMatcher","call","apply","SKIP_TOKEN","addToResyncTokens","importLexerState","shouldInRepetitionRecoveryBeTried","expectTokAfterLastMatch","nextTokIdx","notStuck","undefined","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","follows","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","isMisMatchedTokInFollows","possibleFollowsTokType","isNextTokenWhatIsExpected","isInCurrentRuleReSyncSet","tokenTypeIdx","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","nextToken","k","nextTokenType","tokenType","RULE_STACK","length","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","LAST_EXPLICIT_RULE_STACK","idx","followStack","currKey","followName","token","resyncTokens","push","reSyncTo","prodFunc","args","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","pathRuleStack","getHumanReadableRuleStack","pathOccurrenceStack","ruleStack","occurrenceStack","lastTok","lastTokOccurrence","currIdx","currShortName","key","getKeyForAutomaticLookahead","firstAfterRepInfo","currRuleName","ruleGrammar","getGAstProductions","walker","startWalking","occurrence","isEndOfRule"],"sources":["/home/spencer/Personal/Bibtex-web-database-master/client/node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js"],"sourcesContent":["import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n    this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // arguments to try and perform resync into the next iteration of the many are missing\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return contains(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var nextTokenType = nextToken.tokenType;\n            if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n                return nextTokenType;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n            explicitRuleStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_STACK[idx]; });\n            explicitOccurrenceStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_OCCURRENCE_STACK[idx]; });\n        }\n        // TODO: only iterate over explicit rules here\n        return map(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        var followName = followKey.ruleName +\n            followKey.idxInCallingRule +\n            IN +\n            followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n            return map(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {\n                return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);\n            });\n        }\n        else {\n            return map(this.RULE_STACK, function (currShortName) {\n                return _this.shortRuleNameToFullName(currShortName);\n            });\n        }\n    };\n    return Recoverable;\n}());\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}